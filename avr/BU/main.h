
/*DEFINES*/
#ifndef _MEGA_MAIN_H_
#define _MEGA_MAIN_H_

#include <types.h>

/*Задержка между измерениями температуры, мс*/
#define DALAY_MEZ 60000

/*Верси прошивки*/
#define FIRMWARE_VERSION 0x01
/*****************************************************
	***	Распределение адресов ЕЕПРОМ 	***
*****************************************************/
/*Адрес для записи настроек*/
#define ADR_STS 0x00
/*Проверочный символ при считывании настроек*/
#define MG_STS 0x89

/*Период мигания подсветки кнопок*/
#define TMIG  500
/*Адрес для записи флага состояния*/
#define ADR_STATE 0x0150

//Обратная связь по 30 вольтам
#define FB ((PINA&BIT(3)))

//Обратная связь по +24 вольтам
#define D24 ((PIND&BIT(1)))

/*****************************************************
	***	Антидребезг 	***
*****************************************************/
//{
/*Тупо по схеме...*/
#define SIGNAL_D6_7	((PINA&BIT(0))^BIT(0))
#define SIGNAL_D6_6	((PINA&BIT(1))^BIT(1))
#define SIGNAL_D6_2	((PINA&BIT(2))^BIT(2))

#define SIGNAL_D4_2	((PINC&BIT(0))^BIT(0))
#define SIGNAL_D4_3	((PINC&BIT(1))^BIT(1))
#define SIGNAL_D4_6	((PINC&BIT(2))^BIT(2))
#define SIGNAL_D4_7	((PINC&BIT(3))^BIT(3))
#define SIGNAL_D5_2	((PINC&BIT(4))^BIT(4))
#define SIGNAL_D5_3	((PINC&BIT(5))^BIT(5))
#define SIGNAL_D5_6	((PINC&BIT(6))^BIT(6))
#define SIGNAL_D5_7	((PINC&BIT(7))^BIT(7))

#define SIGNAL_D6_3	((PIND&BIT(0))^BIT(0))
#define SIGNAL_DV45	((PIND&BIT(6))^BIT(6))
#define SIGNAL_DV5	((PIND&BIT(7))^BIT(7))

#define SIGNAL_KO	((PINE&BIT(4))^BIT(4))
#define SIGNAL_KZ	((PINE&BIT(5))^BIT(5))

#define SIGNAL_KR1	((PINE&BIT(3))^BIT(3))
#define SIGNAL_KR2	((PINE&BIT(3))^BIT(3))


#define SIGNAL_D7_7	((PINF&BIT(4))^BIT(4))
#define SIGNAL_D7_6	((PINF&BIT(5))^BIT(5))
#define SIGNAL_D7_3	((PINF&BIT(6))^BIT(6))
#define SIGNAL_D7_2	((PINF&BIT(7))^BIT(7))


// номера для антидребезговой буферезации входов
enum{
	N_SIGNAL_D6_7,
	N_SIGNAL_D6_6,
	N_SIGNAL_D6_2,

	N_SIGNAL_D4_2,
	N_SIGNAL_D4_3,
	N_SIGNAL_D4_6,
	N_SIGNAL_D4_7,
	N_SIGNAL_D5_2,
	N_SIGNAL_D5_3,
	N_SIGNAL_D5_6,
	N_SIGNAL_D5_7,

	//N_SIGNAL_D6_3,
	N_SIGNAL_DV45,
	N_SIGNAL_DV5,

	N_SIGNAL_KO,
	N_SIGNAL_KZ,

	N_SIGNAL_KR1,
	N_SIGNAL_KR2,
	
	N_SIGNAL_D7_7,
	N_SIGNAL_D7_6,
	N_SIGNAL_D7_3,
	N_SIGNAL_D7_2,
	
	N_SIGNAL_BUF_COUNT
};

/*антидребезг по-умолчанию, мс*/
#define DEF_DEB_TIME	25

// На будущее мегамакрос
#define TIME_NOW timer0_getCounter()

/***************************************************************
	Вот тут переводим на человеческие имена названия датчиков 
****************************************************************/
/*"Открыто"*/
#define S_OPEN	(debounce[N_SIGNAL_D6_7])
/*Закрыто*/
#define	S_CLOSED	(debounce[N_SIGNAL_D6_6])



/*Ну типа "Поджато 2"*/
#define S_COMPRESSED_2	(debounce[N_SIGNAL_D4_2])
/*Ну типа "Поджато 1"*/
#define S_COMPRESSED_1	(debounce[N_SIGNAL_D4_3])
/*Мёртвая точка 2*/
#define S_LOGJAM_2		(debounce[N_SIGNAL_D4_6])
/*Мёртвая точка 1*/
#define S_LOGJAM_1		(debounce[N_SIGNAL_D4_7])

/*Заблокировано (секретка)*/
#define S_SEKRETKA		(debounce[N_SIGNAL_D5_2])
/*Заблокировано (Замок)*/
#define S_LOCK			(debounce[N_SIGNAL_D5_3]|debounce[N_SIGNAL_D7_3])

/*Подножка сложена*/
#define S_FOOTBOARD		(debounce[N_SIGNAL_D5_6]==0)

/*Датчик Y2*/
#define S_Y2			(debounce[N_SIGNAL_D5_7])


/*V>45*/
#define S_V45			(debounce[N_SIGNAL_DV45])

/*V>5*/
#define S_V5			(debounce[N_SIGNAL_DV5])

/*Кнопа "Открыть"*/
#define S_KO			(debounce[N_SIGNAL_KO])

/*Кнопа "Закрыть"*/
#define S_KZ			(debounce[N_SIGNAL_KZ])

/*Помеха в створе 1*/
#define S_DIST_AL_1		(debounce[N_SIGNAL_KR1]) 

/*Помеха в створе 2*/
#define S_DIST_AL_2		(debounce[N_SIGNAL_KR2]) 


/*неисправна кромка 1*/
#define S_KRERR1		(debounce[N_SIGNAL_D7_6]) 

/*неисправна кромка 2*/
#define S_KRERR2		(debounce[N_SIGNAL_D7_7]) 


/*Режим работы автоматический/ручной*/
#define S_MAN_AUTO		(debounce[N_SIGNAL_D7_2]) 

/*и т.д...*/
//}
/*Ручные боковые двери*/
/*Правая*/
#define S_HAND_RS_SECRET	(debounce[N_SIGNAL_D5_6])
#define S_HAND_RS_LOCK		(debounce[N_SIGNAL_D5_7])

/*Левая*/
#define S_HAND_LS_SECRET	(debounce[N_SIGNAL_D4_6])
#define S_HAND_LS_LOCK		(debounce[N_SIGNAL_D4_7])


/*Период меандра баззера при прерывистом сигнале, мс */
#define BUZZ_CYCLE 500
/*Режимы buzzera*/
enum {
	CONTINUOUS,
	INTERRUPTED,
	UNLIMITED
};

/*Регистр неисправностей bug_reg*/
enum{
	BUG_M1,// неисправен двигатель М1
	BUG_M2,
	BUG_M3,
	BUG_MF1,// муфта
	BUG_OPEN,// датчик отрыто
	BUG_POS, //положение
	BUG_CLOSE,//закрыто
	BUG_COMPRES1,// поджато 1
	BUG_COMPRES2,// поджато 2
	BUG_Y1,// соленоид Y1
	BUG_Y2,//соленоид Y2
	BUG_PROTECTIVE_EDGE,// защитные кромки
	BUG_LOGJAM1,// Мёртвая точка 1
	BUG_LOGJAM2// Мёртвая точка 2
};
/*Структурка двери*/
typedef struct{
	uint8_t type;//тип
	/*=== Необходимые для работы переменные(настройки), передаваемые от БД ===*/
	//{
	/*== Для боковой двери ==*/
	/*время работы пусковой катушки соленоида  разблокировки Y1 , мс*/
	uint16_t sts_ts;
	/*скорость перемещения створки двери на прямолинейном участке движения , %*/
	uint8_t sts_Vr;
	/*скорость перемещения створки двери на участке торможения при открытии/закрытии двери  (скорость дотягивания) , %*/
	uint8_t sts_Vd;
	/*время открытия/закрытия двери по импульсам датчика положения, мс */
	uint16_t sts_tdp;
	/*момент перехода  с рабочей   скорости  на скорость дотягивания по датчику "Положение", %*/
	uint8_t sts_Srp;
	/*максимальное время работы двигателей  устройств фиксации М2, М3, мс*/
	uint16_t sts_tf;
	/*время задержки выключения двигателей устройств фиксации М2*, М3* по датчикам  S1*,S2* (поджато 1, поджато 2), мс*/
	uint16_t sts_tzp;
	/*момент перехода по времени   с рабочей   скорости  на скорость дотягивания  при открытии/закрытии двери , мс*/
	uint16_t sts_tr;
	/*наличие электромагнита блокировки Y2* (есть/нет), вкл./откл*/
	uint8_t sts_sb;
	/*включение зуммера (внутренний/внешний)*/
	uint8_t sts_zum;
	/*активация режима мигания  зеленой подсветки кнопок с частотой 1 Гц при переходе двери в ручной режим работы*/
	uint8_t sts_zmig;
	/*время задержки выключения маршевого двигателя М1*  по датчику S10* (закрыто), мс*/
	uint16_t sts_tzz;
	/*Максимальное значение тока двигателя М1 при закрытии двери*, мА*/
	uint16_t sts_Im;
	/*Максимальное разрешённое время перемещения двери, мс*/
	uint16_t sts_tpd;
	/*температура перехода в ручной режим по собственному датчику температуры БУ боковой двери, градусы Цельсия*/
	int16_t sts_Tr1;
	/*значение температур, при которой происходит перевод двери в ручной режим работы( котроль по значению от БД)*/
	int16_t sts_Tr2;

	/*==  Для торцевой двери ==*/
	/*Всё, что сверху + ...*/
	/*контроль работы защиты М1 по току при состоянии двери закрыто на 95% и более*/
	uint8_t sts_kzz;
	/*время нахождения дверей в открытом положени, мс*/
	uint16_t sts_top;
	/*время задержки выключения маршевого двигателя М1* после срабатывания датчика «закрыто» S2, мс*/
	uint16_t sts_tz;
	
	/*максимальное кол-во импульсов от датчика "Положение"*/
	uint16_t sts_max_impuls;
	/*=======================================================================================*/
	//}
	/*Расстояние, которое проехала дверь по датчику "Положение", %*/
	uint8_t distance;
	/*Режим работы (автомат/ручной)*/
	uint8_t work_mode; 
	/*Состояние двери(откр., закр., и т.п.)*/
	uint8_t state;
}TDoor;

/*Структурка для ШИМа*/
typedef struct {
	/*Напрвавление(open,close)*/
	uint8_t direction;
	/*Уровень ШИМа*/
	uint8_t power;
}TPWM;
/*Направление жвижения ШИМ*/
enum{
	OPEN=0,
	CLOSE
};


/*Адреса*/

#define ADDR1	((PINB&BIT(4))^BIT(4))
#define ADDR2	((PINB&BIT(5))^BIT(5))
#define ADDR3	((PINB&BIT(6))^BIT(6))
#define ADDR4	((PINB&BIT(7))^BIT(7))

/*Порт подсветкой кнопок*/
#define LED_PORT	PORTE
/*****************************************************
	***	Прототипы 	***
*****************************************************/
/**********************************************************************************************
	Баззер 
 Функция в зависимости от типа баззера(внутренний/внешний) держит нужный пин в высоком уровне,
 иначе переводит пин в низкий уровень
***********************************************************************************************/
void
Check_Buzzer(void);
/*****************************************************************
	Баззер
Функция устанавливает время, в течении которого должен пищать вачдог
Input  - время бибикания, мс 
*******************************************************************/
void
Set_Buzzer(uint16_t time,uint8_t mode);

/*****************************************************
	Функция работы с настройками
	INPUT: operation
		0 - Загрузить из еепром
		1 - Сбросить к заводским
		2 - Сохранить в еепром
	RETURN 1 -Ok,0 - error
*****************************************************/
uint8_t 
Work_STS(uint8_t operation);

/********************************************
	Измеряем ток
*******************************************/
void
Get_I(void);

/************************************************
	Функция изменения уровня и направления ШИМа
	dir - направление движения (открытие/закрытие)
	pow - уровень ШИМа в %
*************************************************/
void 
Set_PWM(uint8_t dir, uint8_t pow);

/********************************************
	Функция остановки ШИМа
*******************************************/
void
Stop_PWM(void);
#endif